<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python으로 구현하는 분산 이산 이벤트 시뮬레이션 - 재영의 블로그</title>
    <meta name="description" content="MPI, Ray, ZeroMQ를 활용한 대규모 분산 DES 시스템 구축">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="alternate" type="application/rss+xml" title="재영의 블로그 RSS" href="/tech/ko/feed.xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <script>
        // Apply saved theme immediately to prevent flash
        const theme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', theme);
        // Language preference
        const lang = localStorage.getItem('lang') || 'ko';
    </script>
    <script src="/assets/js/theme-switcher.js" defer></script>
</head>
<body>
    <header>
        <nav>
            <a href="/tech/ko/" class="site-title" data-nav-link>재영의 블로그</a>
            <div class="nav-links">
                <a href="/tech/ko/" data-nav-link>홈</a>
                <a href="/tech/ko/categories.html" data-nav-link>카테고리</a>
                <a href="/tech/ko/tags.html" data-nav-link>태그</a>
                <a href="/tech/ko/archive.html" data-nav-link>아카이브</a>
                <a href="/tech/ko/about.html" data-nav-link>소개</a>
                <select id="lang-select" aria-label="Select language" style="background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); cursor: pointer; font-size: 0.9rem; margin-right: 0.5rem;">
                    <option value="en">English</option>
                    <option value="ko">한국어</option>
                </select>
                <button id="theme-toggle" aria-label="다크 모드 전환" style="background: none; border: none; cursor: pointer; color: var(--text-secondary); font-size: 1.2rem;">
                    <span id="theme-icon">🌙</span>
                </button>
            </div>
        </nav>
    </header>

    <main>
        <article class="post">
    <header class="post-header">
        <h1>Python으로 구현하는 분산 이산 이벤트 시뮬레이션</h1>
        <time datetime=""2024-04-05T00:00:00.000Z"">April 5, 2024</time>
        
        <div style="margin-top: 1rem;">
            <a href="/tech/ko/categories/distributed-systems.html" class="category-badge">분산 시스템</a>
        </div>
        
        
        <div class="tags" style="margin-top: 1rem;">
            
            <a href="/tech/ko/tags/python.html" class="tag">python</a>
            
            <a href="/tech/ko/tags/distributed.html" class="tag">distributed</a>
            
            <a href="/tech/ko/tags/simulation.html" class="tag">simulation</a>
            
            <a href="/tech/ko/tags/mpi.html" class="tag">mpi</a>
            
            <a href="/tech/ko/tags/ray.html" class="tag">ray</a>
            
            <a href="/tech/ko/tags/parallel.html" class="tag">parallel</a>
            
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="python-">Python으로 구현하는 분산 이산 이벤트 시뮬레이션</h1>
<p>수백만 개체를 시뮬레이션하기 위해서는 단일 머신의 한계를 넘어 분산 시스템으로 확장해야 합니다. Python에서 분산 DES를 구현하는 고급 기법들을 살펴봅니다.</p>
<h2 id="time-warp-">Time Warp과 낙관적 동기화</h2>
<p>Jefferson의 Virtual Time 알고리즘 구현:</p>
<pre><code class="language-python">import heapq
from dataclasses import dataclass, field
from typing import Dict, List, Optional
import pickle
import asyncio

@dataclass
class TimeWarpEvent:
    &quot;&quot;&quot;시간 워프 이벤트&quot;&quot;&quot;
    virtual_time: float
    logical_process_id: int
    event_type: str
    data: dict
    anti_message: bool = False
    sent_messages: List = field(default_factory=list)

class LogicalProcess:
    &quot;&quot;&quot;논리 프로세스 (LP)&quot;&quot;&quot;
    def __init__(self, process_id: int):
        self.id = process_id
        self.local_virtual_time = 0.0
        self.global_virtual_time = 0.0

        # 이벤트 큐
        self.input_queue = []
        self.processed_events = []

        # 상태 체크포인트
        self.state_checkpoints = {}
        self.current_state = {}

        # 안티메시지 관리
        self.sent_messages = []
        self.gvt_contribution = 0.0

    def process_event(self, event: TimeWarpEvent):
        &quot;&quot;&quot;이벤트 처리 with 롤백 지원&quot;&quot;&quot;
        if event.virtual_time &lt; self.local_virtual_time:
            # 롤백 필요
            self.rollback_to(event.virtual_time)

        # 상태 체크포인트 저장
        self.save_checkpoint(event.virtual_time)

        # 이벤트 처리
        new_events = self.execute_event(event)

        # 생성된 이벤트 기록
        event.sent_messages = new_events
        self.processed_events.append(event)

        # LVT 업데이트
        self.local_virtual_time = event.virtual_time

        return new_events

    def rollback_to(self, time: float):
        &quot;&quot;&quot;특정 시점으로 롤백&quot;&quot;&quot;
        # 미래 이벤트 취소 (안티메시지 전송)
        events_to_cancel = [
            e for e in self.processed_events
            if e.virtual_time &gt;= time
        ]

        for event in events_to_cancel:
            for sent_msg in event.sent_messages:
                anti_msg = TimeWarpEvent(
                    virtual_time=sent_msg.virtual_time,
                    logical_process_id=sent_msg.logical_process_id,
                    event_type=sent_msg.event_type,
                    data=sent_msg.data,
                    anti_message=True
                )
                self.send_message(anti_msg)

        # 상태 복원
        checkpoint_times = sorted([
            t for t in self.state_checkpoints.keys()
            if t &lt; time
        ])

        if checkpoint_times:
            restore_time = checkpoint_times[-1]
            self.current_state = pickle.loads(
                self.state_checkpoints[restore_time]
            )
            self.local_virtual_time = restore_time

            # 재실행
            events_to_replay = [
                e for e in self.input_queue
                if restore_time &lt;= e.virtual_time &lt; time
            ]
            for event in sorted(events_to_replay,
                              key=lambda x: x.virtual_time):
                self.process_event(event)</code></pre>
<h2 id="mpi-">MPI 기반 분산 시뮬레이션</h2>
<pre><code class="language-python">from mpi4py import MPI
import numpy as np

class MPIDistributedSimulation:
    &quot;&quot;&quot;MPI 기반 분산 DES&quot;&quot;&quot;

    def __init__(self):
        self.comm = MPI.COMM_WORLD
        self.rank = self.comm.Get_rank()
        self.size = self.comm.Get_size()

        # 파티션된 엔티티
        self.local_entities = {}
        self.entity_partition_map = {}

        # 통신 버퍼
        self.send_buffer = []
        self.recv_buffer = []

    def partition_entities(self, total_entities: int):
        &quot;&quot;&quot;엔티티를 프로세스에 할당&quot;&quot;&quot;
        entities_per_proc = total_entities // self.size
        remainder = total_entities % self.size

        start_idx = self.rank * entities_per_proc + min(self.rank, remainder)
        end_idx = start_idx + entities_per_proc + (1 if self.rank &lt; remainder else 0)

        return range(start_idx, end_idx)

    def run_simulation(self, until_time: float):
        &quot;&quot;&quot;분산 시뮬레이션 실행&quot;&quot;&quot;
        local_time = 0.0
        gvt = 0.0

        while gvt &lt; until_time:
            # 로컬 이벤트 처리
            local_min_time = self.process_local_events()

            # GVT 계산 (Mattern&#39;s algorithm)
            gvt = self.calculate_gvt(local_min_time)

            # 화석 수집 (Fossil collection)
            self.collect_fossils(gvt)

            # 비동기 메시지 교환
            self.exchange_messages_async()

    def calculate_gvt(self, local_min: float) -&gt; float:
        &quot;&quot;&quot;Mattern&#39;s GVT 알고리즘&quot;&quot;&quot;
        # 색상 기반 GVT 계산
        color = 0  # 0: white, 1: red

        # 로컬 최소값 수집
        all_mins = np.zeros(self.size)
        self.comm.Allgather(
            np.array([local_min]),
            all_mins
        )

        # 전이 메시지 카운트
        send_counts = np.zeros(self.size, dtype=np.int32)
        recv_counts = np.zeros(self.size, dtype=np.int32)

        # 메시지 카운트 교환
        self.comm.Alltoall(send_counts, recv_counts)

        # GVT 결정
        if np.array_equal(send_counts, recv_counts):
            return np.min(all_mins)
        else:
            return gvt  # 이전 GVT 유지

    def exchange_messages_async(self):
        &quot;&quot;&quot;비동기 메시지 교환&quot;&quot;&quot;
        requests = []

        # 비동기 송신
        for target_rank, messages in self.send_buffer.items():
            if messages:
                req = self.comm.isend(
                    messages,
                    dest=target_rank,
                    tag=0
                )
                requests.append(req)

        # 비동기 수신
        status = MPI.Status()
        while self.comm.iprobe(source=MPI.ANY_SOURCE, tag=0, status=status):
            source = status.Get_source()
            messages = self.comm.recv(source=source, tag=0)
            self.recv_buffer.extend(messages)

        # 요청 완료 대기
        MPI.Request.Waitall(requests)</code></pre>
<h2 id="ray-actor-">Ray를 활용한 Actor 기반 분산 시뮬레이션</h2>
<pre><code class="language-python">import ray
from ray import actors
import asyncio

@ray.remote
class SimulationActor:
    &quot;&quot;&quot;Ray Actor로 구현된 시뮬레이션 노드&quot;&quot;&quot;

    def __init__(self, actor_id: int, partition: range):
        self.id = actor_id
        self.entities = {}
        self.event_queue = []
        self.current_time = 0.0

        # 엔티티 초기화
        for entity_id in partition:
            self.entities[entity_id] = self._create_entity(entity_id)

        # 다른 액터 참조
        self.peer_actors = {}

    async def process_events_async(self, until_time: float):
        &quot;&quot;&quot;비동기 이벤트 처리&quot;&quot;&quot;
        while self.current_time &lt; until_time:
            if not self.event_queue:
                await asyncio.sleep(0.001)
                continue

            event = heapq.heappop(self.event_queue)
            self.current_time = event.time

            # 로컬 처리
            if event.target_entity in self.entities:
                new_events = self._process_local_event(event)

                # 원격 이벤트 전송
                for new_event in new_events:
                    if new_event.target_entity not in self.entities:
                        await self._send_remote_event(new_event)
            else:
                # 잘못 라우팅된 이벤트
                await self._route_event(event)

    async def _send_remote_event(self, event):
        &quot;&quot;&quot;원격 액터로 이벤트 전송&quot;&quot;&quot;
        target_actor = self._get_target_actor(event.target_entity)
        await target_actor.receive_event.remote(event)

    @ray.method(num_returns=0)
    async def receive_event(self, event):
        &quot;&quot;&quot;외부 이벤트 수신&quot;&quot;&quot;
        heapq.heappush(self.event_queue, event)

# Ray 클러스터 초기화
ray.init(address=&quot;ray://head_node:10001&quot;)

# 분산 시뮬레이션 오케스트레이터
@ray.remote
class SimulationOrchestrator:
    def __init__(self, n_actors: int, n_entities: int):
        self.n_actors = n_actors
        self.n_entities = n_entities

        # 액터 생성
        self.actors = []
        entities_per_actor = n_entities // n_actors

        for i in range(n_actors):
            start = i * entities_per_actor
            end = start + entities_per_actor
            actor = SimulationActor.remote(i, range(start, end))
            self.actors.append(actor)

    async def run_simulation(self, until_time: float):
        &quot;&quot;&quot;분산 시뮬레이션 실행&quot;&quot;&quot;
        # 모든 액터 시작
        tasks = [
            actor.process_events_async.remote(until_time)
            for actor in self.actors
        ]

        # 완료 대기
        await asyncio.gather(*tasks)

        # 결과 수집
        results = ray.get([
            actor.get_statistics.remote()
            for actor in self.actors
        ])

        return self._aggregate_results(results)</code></pre>
<h2 id="zeromq-">ZeroMQ 기반 고성능 메시지 전달</h2>
<pre><code class="language-python">import zmq
import zmq.asyncio
import msgpack
import asyncio

class ZMQSimulationNode:
    &quot;&quot;&quot;ZeroMQ 기반 시뮬레이션 노드&quot;&quot;&quot;

    def __init__(self, node_id: str, coordinator_addr: str):
        self.node_id = node_id
        self.context = zmq.asyncio.Context()

        # 통신 채널
        self.publisher = self.context.socket(zmq.PUB)
        self.subscriber = self.context.socket(zmq.SUB)
        self.coordinator = self.context.socket(zmq.REQ)

        # 연결 설정
        self.publisher.bind(f&quot;tcp://*:{5560 + int(node_id)}&quot;)
        self.coordinator.connect(coordinator_addr)

        # 메시지 큐
        self.outgoing_messages = asyncio.Queue()
        self.incoming_messages = asyncio.Queue()

    async def message_router(self):
        &quot;&quot;&quot;고성능 메시지 라우팅&quot;&quot;&quot;
        while True:
            # 수신 (ZeroMQ의 zero-copy 활용)
            if await self.subscriber.poll(timeout=0):
                topic, message = await self.subscriber.recv_multipart(
                    copy=False
                )

                # MessagePack 역직렬화
                event = msgpack.unpackb(
                    message.buffer,
                    raw=False,
                    use_list=False
                )

                await self.incoming_messages.put(event)

            # 송신
            if not self.outgoing_messages.empty():
                event = await self.outgoing_messages.get()

                # 토픽 기반 라우팅
                topic = f&quot;node_{event[&#39;target_node&#39;]}&quot;.encode()
                message = msgpack.packb(event, use_bin_type=True)

                # 비동기 전송
                await self.publisher.send_multipart(
                    [topic, message],
                    copy=False
                )

    async def synchronize_with_coordinator(self):
        &quot;&quot;&quot;코디네이터와 동기화&quot;&quot;&quot;
        local_state = self.get_local_state()

        # 상태 전송
        await self.coordinator.send_json({
            &#39;node_id&#39;: self.node_id,
            &#39;local_time&#39;: self.current_time,
            &#39;event_count&#39;: len(self.processed_events),
            &#39;state_hash&#39;: hash(str(local_state))
        })

        # 글로벌 동기화 정보 수신
        sync_info = await self.coordinator.recv_json()
        self.apply_synchronization(sync_info)</code></pre>
<h2 id="-">적응형 부하 분산</h2>
<pre><code class="language-python">class AdaptiveLoadBalancer:
    &quot;&quot;&quot;동적 부하 분산&quot;&quot;&quot;

    def __init__(self, n_nodes: int):
        self.n_nodes = n_nodes
        self.node_loads = np.zeros(n_nodes)
        self.migration_threshold = 0.3

    def monitor_load(self, node_id: int, metrics: dict):
        &quot;&quot;&quot;노드 부하 모니터링&quot;&quot;&quot;
        # 복합 메트릭 계산
        load = (
            metrics[&#39;event_queue_size&#39;] * 0.4 +
            metrics[&#39;cpu_usage&#39;] * 0.3 +
            metrics[&#39;memory_usage&#39;] * 0.3
        )
        self.node_loads[node_id] = load

    def rebalance_entities(self):
        &quot;&quot;&quot;엔티티 재분배&quot;&quot;&quot;
        avg_load = np.mean(self.node_loads)
        std_load = np.std(self.node_loads)

        if std_load / avg_load &gt; self.migration_threshold:
            # 부하가 높은 노드와 낮은 노드 식별
            overloaded = np.where(
                self.node_loads &gt; avg_load + std_load
            )[0]
            underloaded = np.where(
                self.node_loads &lt; avg_load - std_load
            )[0]

            # 마이그레이션 계획 생성
            migrations = []
            for source in overloaded:
                for target in underloaded:
                    n_entities = self._calculate_migration_size(
                        source, target, avg_load
                    )
                    migrations.append((source, target, n_entities))

            return migrations
        return []

    def _calculate_migration_size(self, source: int, target: int,
                                 target_load: float) -&gt; int:
        &quot;&quot;&quot;마이그레이션할 엔티티 수 계산&quot;&quot;&quot;
        load_diff = self.node_loads[source] - target_load
        entities_per_load = 100  # 조정 가능한 파라미터

        return int(load_diff * entities_per_load)</code></pre>
<p>분산 DES 시스템을 구축하면 클라우드 규모의 시뮬레이션을 실행할 수 있으며, 수십억 개의 이벤트를 처리할 수 있습니다.</p>

    </div>

    <nav class="post-nav">
        
        <a href="/tech/ko/posts/2024-05-15-python-jit-simulation.html" class="prev">← 시뮬레이션을 위한 Python JIT 컴파일러 최적화</a>
        
        
        <a href="/tech/ko/posts/2024-03-10-cpython-extension-simulation-performance.html" class="next">시뮬레이션 성능을 위한 CPython C 확장 모듈 개발 →</a>
        
    </nav>
</article>
    </main>

    <footer>
        <div class="footer-content">
            <p>&copy; 2025 Jae · Built with custom static site generator</p>
            <div class="footer-links">
                <a href="/tech/ko/feed.xml">RSS</a>
                
                
            </div>
        </div>
    </footer>

    <script>
        // Parse current URL to get blog and language
        const pathParts = window.location.pathname.split('/').filter(p => p);
        const blogPath = pathParts[0] ? '/' + pathParts[0] : '';
        const currentLang = pathParts[1] || 'en';

        // Update navigation links - they should already be correct from server
        // This is just for dynamic client-side updates if needed
        function updateNavLinks() {
            const navLinks = document.querySelectorAll('[data-nav-link]');
            // Links are already fixed by the server, no client-side processing needed
        }

        // Theme toggle functionality
        const toggleBtn = document.getElementById('theme-toggle');
        const icon = document.getElementById('theme-icon');

        function updateThemeIcon(theme) {
            icon.textContent = theme === 'dark' ? '☀️' : '🌙';
        }

        updateThemeIcon(localStorage.getItem('theme') || 'light');

        toggleBtn?.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
            updateThemeIcon(next);
        });

        // Language dropdown functionality
        const langSelect = document.getElementById('lang-select');
        if (langSelect) {
            // Set current language in dropdown
            langSelect.value = currentLang;

            langSelect.addEventListener('change', (e) => {
                const selectedLang = e.target.value;
                localStorage.setItem('lang', selectedLang);

                // Simply replace the language code in the current path
                const newPath = window.location.pathname.replace(
                    /\/[a-z]{2}\//,
                    '/' + selectedLang + '/'
                );

                window.location.href = newPath;
            });
        }
    </script>
</body>
</html>