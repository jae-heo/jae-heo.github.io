<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pythonìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ë¶„ì‚° ì´ì‚° ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜ - ì¬ì˜ì˜ ë¸”ë¡œê·¸</title>
    <meta name="description" content="MPI, Ray, ZeroMQë¥¼ í™œìš©í•œ ëŒ€ê·œëª¨ ë¶„ì‚° DES ì‹œìŠ¤í…œ êµ¬ì¶•">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="alternate" type="application/rss+xml" title="ì¬ì˜ì˜ ë¸”ë¡œê·¸ RSS" href="/tech/ko/feed.xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <script>
        // Apply saved theme immediately to prevent flash
        const theme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', theme);
        // Language preference
        const lang = localStorage.getItem('lang') || 'ko';
    </script>
    <script src="/assets/js/theme-switcher.js" defer></script>
</head>
<body>
    <header>
        <nav>
            <a href="/tech/ko/" class="site-title" data-nav-link>ì¬ì˜ì˜ ë¸”ë¡œê·¸</a>
            <div class="nav-links">
                <a href="/tech/ko/" data-nav-link>í™ˆ</a>
                <a href="/tech/ko/categories.html" data-nav-link>ì¹´í…Œê³ ë¦¬</a>
                <a href="/tech/ko/tags.html" data-nav-link>íƒœê·¸</a>
                <a href="/tech/ko/archive.html" data-nav-link>ì•„ì¹´ì´ë¸Œ</a>
                <a href="/tech/ko/about.html" data-nav-link>ì†Œê°œ</a>
                <select id="lang-select" aria-label="Select language" style="background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); cursor: pointer; font-size: 0.9rem; margin-right: 0.5rem;">
                    <option value="en">English</option>
                    <option value="ko">í•œêµ­ì–´</option>
                </select>
                <button id="theme-toggle" aria-label="ë‹¤í¬ ëª¨ë“œ ì „í™˜" style="background: none; border: none; cursor: pointer; color: var(--text-secondary); font-size: 1.2rem;">
                    <span id="theme-icon">ğŸŒ™</span>
                </button>
            </div>
        </nav>
    </header>

    <main>
        <article class="post">
    <header class="post-header">
        <h1>Pythonìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ë¶„ì‚° ì´ì‚° ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜</h1>
        <time datetime=""2024-04-05T00:00:00.000Z"">April 5, 2024</time>
        
        <div style="margin-top: 1rem;">
            <a href="/tech/ko/categories/distributed-systems.html" class="category-badge">ë¶„ì‚° ì‹œìŠ¤í…œ</a>
        </div>
        
        
        <div class="tags" style="margin-top: 1rem;">
            
            <a href="/tech/ko/tags/python.html" class="tag">python</a>
            
            <a href="/tech/ko/tags/distributed.html" class="tag">distributed</a>
            
            <a href="/tech/ko/tags/simulation.html" class="tag">simulation</a>
            
            <a href="/tech/ko/tags/mpi.html" class="tag">mpi</a>
            
            <a href="/tech/ko/tags/ray.html" class="tag">ray</a>
            
            <a href="/tech/ko/tags/parallel.html" class="tag">parallel</a>
            
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="python-">Pythonìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ë¶„ì‚° ì´ì‚° ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜</h1>
<p>ìˆ˜ë°±ë§Œ ê°œì²´ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸° ìœ„í•´ì„œëŠ” ë‹¨ì¼ ë¨¸ì‹ ì˜ í•œê³„ë¥¼ ë„˜ì–´ ë¶„ì‚° ì‹œìŠ¤í…œìœ¼ë¡œ í™•ì¥í•´ì•¼ í•©ë‹ˆë‹¤. Pythonì—ì„œ ë¶„ì‚° DESë¥¼ êµ¬í˜„í•˜ëŠ” ê³ ê¸‰ ê¸°ë²•ë“¤ì„ ì‚´í´ë´…ë‹ˆë‹¤.</p>
<h2 id="time-warp-">Time Warpê³¼ ë‚™ê´€ì  ë™ê¸°í™”</h2>
<p>Jeffersonì˜ Virtual Time ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„:</p>
<pre><code class="language-python">import heapq
from dataclasses import dataclass, field
from typing import Dict, List, Optional
import pickle
import asyncio

@dataclass
class TimeWarpEvent:
    &quot;&quot;&quot;ì‹œê°„ ì›Œí”„ ì´ë²¤íŠ¸&quot;&quot;&quot;
    virtual_time: float
    logical_process_id: int
    event_type: str
    data: dict
    anti_message: bool = False
    sent_messages: List = field(default_factory=list)

class LogicalProcess:
    &quot;&quot;&quot;ë…¼ë¦¬ í”„ë¡œì„¸ìŠ¤ (LP)&quot;&quot;&quot;
    def __init__(self, process_id: int):
        self.id = process_id
        self.local_virtual_time = 0.0
        self.global_virtual_time = 0.0

        # ì´ë²¤íŠ¸ í
        self.input_queue = []
        self.processed_events = []

        # ìƒíƒœ ì²´í¬í¬ì¸íŠ¸
        self.state_checkpoints = {}
        self.current_state = {}

        # ì•ˆí‹°ë©”ì‹œì§€ ê´€ë¦¬
        self.sent_messages = []
        self.gvt_contribution = 0.0

    def process_event(self, event: TimeWarpEvent):
        &quot;&quot;&quot;ì´ë²¤íŠ¸ ì²˜ë¦¬ with ë¡¤ë°± ì§€ì›&quot;&quot;&quot;
        if event.virtual_time &lt; self.local_virtual_time:
            # ë¡¤ë°± í•„ìš”
            self.rollback_to(event.virtual_time)

        # ìƒíƒœ ì²´í¬í¬ì¸íŠ¸ ì €ì¥
        self.save_checkpoint(event.virtual_time)

        # ì´ë²¤íŠ¸ ì²˜ë¦¬
        new_events = self.execute_event(event)

        # ìƒì„±ëœ ì´ë²¤íŠ¸ ê¸°ë¡
        event.sent_messages = new_events
        self.processed_events.append(event)

        # LVT ì—…ë°ì´íŠ¸
        self.local_virtual_time = event.virtual_time

        return new_events

    def rollback_to(self, time: float):
        &quot;&quot;&quot;íŠ¹ì • ì‹œì ìœ¼ë¡œ ë¡¤ë°±&quot;&quot;&quot;
        # ë¯¸ë˜ ì´ë²¤íŠ¸ ì·¨ì†Œ (ì•ˆí‹°ë©”ì‹œì§€ ì „ì†¡)
        events_to_cancel = [
            e for e in self.processed_events
            if e.virtual_time &gt;= time
        ]

        for event in events_to_cancel:
            for sent_msg in event.sent_messages:
                anti_msg = TimeWarpEvent(
                    virtual_time=sent_msg.virtual_time,
                    logical_process_id=sent_msg.logical_process_id,
                    event_type=sent_msg.event_type,
                    data=sent_msg.data,
                    anti_message=True
                )
                self.send_message(anti_msg)

        # ìƒíƒœ ë³µì›
        checkpoint_times = sorted([
            t for t in self.state_checkpoints.keys()
            if t &lt; time
        ])

        if checkpoint_times:
            restore_time = checkpoint_times[-1]
            self.current_state = pickle.loads(
                self.state_checkpoints[restore_time]
            )
            self.local_virtual_time = restore_time

            # ì¬ì‹¤í–‰
            events_to_replay = [
                e for e in self.input_queue
                if restore_time &lt;= e.virtual_time &lt; time
            ]
            for event in sorted(events_to_replay,
                              key=lambda x: x.virtual_time):
                self.process_event(event)</code></pre>
<h2 id="mpi-">MPI ê¸°ë°˜ ë¶„ì‚° ì‹œë®¬ë ˆì´ì…˜</h2>
<pre><code class="language-python">from mpi4py import MPI
import numpy as np

class MPIDistributedSimulation:
    &quot;&quot;&quot;MPI ê¸°ë°˜ ë¶„ì‚° DES&quot;&quot;&quot;

    def __init__(self):
        self.comm = MPI.COMM_WORLD
        self.rank = self.comm.Get_rank()
        self.size = self.comm.Get_size()

        # íŒŒí‹°ì…˜ëœ ì—”í‹°í‹°
        self.local_entities = {}
        self.entity_partition_map = {}

        # í†µì‹  ë²„í¼
        self.send_buffer = []
        self.recv_buffer = []

    def partition_entities(self, total_entities: int):
        &quot;&quot;&quot;ì—”í‹°í‹°ë¥¼ í”„ë¡œì„¸ìŠ¤ì— í• ë‹¹&quot;&quot;&quot;
        entities_per_proc = total_entities // self.size
        remainder = total_entities % self.size

        start_idx = self.rank * entities_per_proc + min(self.rank, remainder)
        end_idx = start_idx + entities_per_proc + (1 if self.rank &lt; remainder else 0)

        return range(start_idx, end_idx)

    def run_simulation(self, until_time: float):
        &quot;&quot;&quot;ë¶„ì‚° ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰&quot;&quot;&quot;
        local_time = 0.0
        gvt = 0.0

        while gvt &lt; until_time:
            # ë¡œì»¬ ì´ë²¤íŠ¸ ì²˜ë¦¬
            local_min_time = self.process_local_events()

            # GVT ê³„ì‚° (Mattern&#39;s algorithm)
            gvt = self.calculate_gvt(local_min_time)

            # í™”ì„ ìˆ˜ì§‘ (Fossil collection)
            self.collect_fossils(gvt)

            # ë¹„ë™ê¸° ë©”ì‹œì§€ êµí™˜
            self.exchange_messages_async()

    def calculate_gvt(self, local_min: float) -&gt; float:
        &quot;&quot;&quot;Mattern&#39;s GVT ì•Œê³ ë¦¬ì¦˜&quot;&quot;&quot;
        # ìƒ‰ìƒ ê¸°ë°˜ GVT ê³„ì‚°
        color = 0  # 0: white, 1: red

        # ë¡œì»¬ ìµœì†Œê°’ ìˆ˜ì§‘
        all_mins = np.zeros(self.size)
        self.comm.Allgather(
            np.array([local_min]),
            all_mins
        )

        # ì „ì´ ë©”ì‹œì§€ ì¹´ìš´íŠ¸
        send_counts = np.zeros(self.size, dtype=np.int32)
        recv_counts = np.zeros(self.size, dtype=np.int32)

        # ë©”ì‹œì§€ ì¹´ìš´íŠ¸ êµí™˜
        self.comm.Alltoall(send_counts, recv_counts)

        # GVT ê²°ì •
        if np.array_equal(send_counts, recv_counts):
            return np.min(all_mins)
        else:
            return gvt  # ì´ì „ GVT ìœ ì§€

    def exchange_messages_async(self):
        &quot;&quot;&quot;ë¹„ë™ê¸° ë©”ì‹œì§€ êµí™˜&quot;&quot;&quot;
        requests = []

        # ë¹„ë™ê¸° ì†¡ì‹ 
        for target_rank, messages in self.send_buffer.items():
            if messages:
                req = self.comm.isend(
                    messages,
                    dest=target_rank,
                    tag=0
                )
                requests.append(req)

        # ë¹„ë™ê¸° ìˆ˜ì‹ 
        status = MPI.Status()
        while self.comm.iprobe(source=MPI.ANY_SOURCE, tag=0, status=status):
            source = status.Get_source()
            messages = self.comm.recv(source=source, tag=0)
            self.recv_buffer.extend(messages)

        # ìš”ì²­ ì™„ë£Œ ëŒ€ê¸°
        MPI.Request.Waitall(requests)</code></pre>
<h2 id="ray-actor-">Rayë¥¼ í™œìš©í•œ Actor ê¸°ë°˜ ë¶„ì‚° ì‹œë®¬ë ˆì´ì…˜</h2>
<pre><code class="language-python">import ray
from ray import actors
import asyncio

@ray.remote
class SimulationActor:
    &quot;&quot;&quot;Ray Actorë¡œ êµ¬í˜„ëœ ì‹œë®¬ë ˆì´ì…˜ ë…¸ë“œ&quot;&quot;&quot;

    def __init__(self, actor_id: int, partition: range):
        self.id = actor_id
        self.entities = {}
        self.event_queue = []
        self.current_time = 0.0

        # ì—”í‹°í‹° ì´ˆê¸°í™”
        for entity_id in partition:
            self.entities[entity_id] = self._create_entity(entity_id)

        # ë‹¤ë¥¸ ì•¡í„° ì°¸ì¡°
        self.peer_actors = {}

    async def process_events_async(self, until_time: float):
        &quot;&quot;&quot;ë¹„ë™ê¸° ì´ë²¤íŠ¸ ì²˜ë¦¬&quot;&quot;&quot;
        while self.current_time &lt; until_time:
            if not self.event_queue:
                await asyncio.sleep(0.001)
                continue

            event = heapq.heappop(self.event_queue)
            self.current_time = event.time

            # ë¡œì»¬ ì²˜ë¦¬
            if event.target_entity in self.entities:
                new_events = self._process_local_event(event)

                # ì›ê²© ì´ë²¤íŠ¸ ì „ì†¡
                for new_event in new_events:
                    if new_event.target_entity not in self.entities:
                        await self._send_remote_event(new_event)
            else:
                # ì˜ëª» ë¼ìš°íŒ…ëœ ì´ë²¤íŠ¸
                await self._route_event(event)

    async def _send_remote_event(self, event):
        &quot;&quot;&quot;ì›ê²© ì•¡í„°ë¡œ ì´ë²¤íŠ¸ ì „ì†¡&quot;&quot;&quot;
        target_actor = self._get_target_actor(event.target_entity)
        await target_actor.receive_event.remote(event)

    @ray.method(num_returns=0)
    async def receive_event(self, event):
        &quot;&quot;&quot;ì™¸ë¶€ ì´ë²¤íŠ¸ ìˆ˜ì‹ &quot;&quot;&quot;
        heapq.heappush(self.event_queue, event)

# Ray í´ëŸ¬ìŠ¤í„° ì´ˆê¸°í™”
ray.init(address=&quot;ray://head_node:10001&quot;)

# ë¶„ì‚° ì‹œë®¬ë ˆì´ì…˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°
@ray.remote
class SimulationOrchestrator:
    def __init__(self, n_actors: int, n_entities: int):
        self.n_actors = n_actors
        self.n_entities = n_entities

        # ì•¡í„° ìƒì„±
        self.actors = []
        entities_per_actor = n_entities // n_actors

        for i in range(n_actors):
            start = i * entities_per_actor
            end = start + entities_per_actor
            actor = SimulationActor.remote(i, range(start, end))
            self.actors.append(actor)

    async def run_simulation(self, until_time: float):
        &quot;&quot;&quot;ë¶„ì‚° ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰&quot;&quot;&quot;
        # ëª¨ë“  ì•¡í„° ì‹œì‘
        tasks = [
            actor.process_events_async.remote(until_time)
            for actor in self.actors
        ]

        # ì™„ë£Œ ëŒ€ê¸°
        await asyncio.gather(*tasks)

        # ê²°ê³¼ ìˆ˜ì§‘
        results = ray.get([
            actor.get_statistics.remote()
            for actor in self.actors
        ])

        return self._aggregate_results(results)</code></pre>
<h2 id="zeromq-">ZeroMQ ê¸°ë°˜ ê³ ì„±ëŠ¥ ë©”ì‹œì§€ ì „ë‹¬</h2>
<pre><code class="language-python">import zmq
import zmq.asyncio
import msgpack
import asyncio

class ZMQSimulationNode:
    &quot;&quot;&quot;ZeroMQ ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜ ë…¸ë“œ&quot;&quot;&quot;

    def __init__(self, node_id: str, coordinator_addr: str):
        self.node_id = node_id
        self.context = zmq.asyncio.Context()

        # í†µì‹  ì±„ë„
        self.publisher = self.context.socket(zmq.PUB)
        self.subscriber = self.context.socket(zmq.SUB)
        self.coordinator = self.context.socket(zmq.REQ)

        # ì—°ê²° ì„¤ì •
        self.publisher.bind(f&quot;tcp://*:{5560 + int(node_id)}&quot;)
        self.coordinator.connect(coordinator_addr)

        # ë©”ì‹œì§€ í
        self.outgoing_messages = asyncio.Queue()
        self.incoming_messages = asyncio.Queue()

    async def message_router(self):
        &quot;&quot;&quot;ê³ ì„±ëŠ¥ ë©”ì‹œì§€ ë¼ìš°íŒ…&quot;&quot;&quot;
        while True:
            # ìˆ˜ì‹  (ZeroMQì˜ zero-copy í™œìš©)
            if await self.subscriber.poll(timeout=0):
                topic, message = await self.subscriber.recv_multipart(
                    copy=False
                )

                # MessagePack ì—­ì§ë ¬í™”
                event = msgpack.unpackb(
                    message.buffer,
                    raw=False,
                    use_list=False
                )

                await self.incoming_messages.put(event)

            # ì†¡ì‹ 
            if not self.outgoing_messages.empty():
                event = await self.outgoing_messages.get()

                # í† í”½ ê¸°ë°˜ ë¼ìš°íŒ…
                topic = f&quot;node_{event[&#39;target_node&#39;]}&quot;.encode()
                message = msgpack.packb(event, use_bin_type=True)

                # ë¹„ë™ê¸° ì „ì†¡
                await self.publisher.send_multipart(
                    [topic, message],
                    copy=False
                )

    async def synchronize_with_coordinator(self):
        &quot;&quot;&quot;ì½”ë””ë„¤ì´í„°ì™€ ë™ê¸°í™”&quot;&quot;&quot;
        local_state = self.get_local_state()

        # ìƒíƒœ ì „ì†¡
        await self.coordinator.send_json({
            &#39;node_id&#39;: self.node_id,
            &#39;local_time&#39;: self.current_time,
            &#39;event_count&#39;: len(self.processed_events),
            &#39;state_hash&#39;: hash(str(local_state))
        })

        # ê¸€ë¡œë²Œ ë™ê¸°í™” ì •ë³´ ìˆ˜ì‹ 
        sync_info = await self.coordinator.recv_json()
        self.apply_synchronization(sync_info)</code></pre>
<h2 id="-">ì ì‘í˜• ë¶€í•˜ ë¶„ì‚°</h2>
<pre><code class="language-python">class AdaptiveLoadBalancer:
    &quot;&quot;&quot;ë™ì  ë¶€í•˜ ë¶„ì‚°&quot;&quot;&quot;

    def __init__(self, n_nodes: int):
        self.n_nodes = n_nodes
        self.node_loads = np.zeros(n_nodes)
        self.migration_threshold = 0.3

    def monitor_load(self, node_id: int, metrics: dict):
        &quot;&quot;&quot;ë…¸ë“œ ë¶€í•˜ ëª¨ë‹ˆí„°ë§&quot;&quot;&quot;
        # ë³µí•© ë©”íŠ¸ë¦­ ê³„ì‚°
        load = (
            metrics[&#39;event_queue_size&#39;] * 0.4 +
            metrics[&#39;cpu_usage&#39;] * 0.3 +
            metrics[&#39;memory_usage&#39;] * 0.3
        )
        self.node_loads[node_id] = load

    def rebalance_entities(self):
        &quot;&quot;&quot;ì—”í‹°í‹° ì¬ë¶„ë°°&quot;&quot;&quot;
        avg_load = np.mean(self.node_loads)
        std_load = np.std(self.node_loads)

        if std_load / avg_load &gt; self.migration_threshold:
            # ë¶€í•˜ê°€ ë†’ì€ ë…¸ë“œì™€ ë‚®ì€ ë…¸ë“œ ì‹ë³„
            overloaded = np.where(
                self.node_loads &gt; avg_load + std_load
            )[0]
            underloaded = np.where(
                self.node_loads &lt; avg_load - std_load
            )[0]

            # ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš ìƒì„±
            migrations = []
            for source in overloaded:
                for target in underloaded:
                    n_entities = self._calculate_migration_size(
                        source, target, avg_load
                    )
                    migrations.append((source, target, n_entities))

            return migrations
        return []

    def _calculate_migration_size(self, source: int, target: int,
                                 target_load: float) -&gt; int:
        &quot;&quot;&quot;ë§ˆì´ê·¸ë ˆì´ì…˜í•  ì—”í‹°í‹° ìˆ˜ ê³„ì‚°&quot;&quot;&quot;
        load_diff = self.node_loads[source] - target_load
        entities_per_load = 100  # ì¡°ì • ê°€ëŠ¥í•œ íŒŒë¼ë¯¸í„°

        return int(load_diff * entities_per_load)</code></pre>
<p>ë¶„ì‚° DES ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ë©´ í´ë¼ìš°ë“œ ê·œëª¨ì˜ ì‹œë®¬ë ˆì´ì…˜ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìœ¼ë©°, ìˆ˜ì‹­ì–µ ê°œì˜ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

    </div>

    <nav class="post-nav">
        
        <a href="/tech/ko/posts/2024-05-15-python-jit-simulation.html" class="prev">â† ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ Python JIT ì»´íŒŒì¼ëŸ¬ ìµœì í™”</a>
        
        
        <a href="/tech/ko/posts/2024-03-10-cpython-extension-simulation-performance.html" class="next">ì‹œë®¬ë ˆì´ì…˜ ì„±ëŠ¥ì„ ìœ„í•œ CPython C í™•ì¥ ëª¨ë“ˆ ê°œë°œ â†’</a>
        
    </nav>
</article>
    </main>

    <footer>
        <div class="footer-content">
            <p>&copy; 2025 Jae Â· Built with custom static site generator</p>
            <div class="footer-links">
                <a href="/tech/ko/feed.xml">RSS</a>
                
                
            </div>
        </div>
    </footer>

    <script>
        // Parse current URL to get blog and language
        const pathParts = window.location.pathname.split('/').filter(p => p);
        const blogPath = pathParts[0] ? '/' + pathParts[0] : '';
        const currentLang = pathParts[1] || 'en';

        // Update navigation links - they should already be correct from server
        // This is just for dynamic client-side updates if needed
        function updateNavLinks() {
            const navLinks = document.querySelectorAll('[data-nav-link]');
            // Links are already fixed by the server, no client-side processing needed
        }

        // Theme toggle functionality
        const toggleBtn = document.getElementById('theme-toggle');
        const icon = document.getElementById('theme-icon');

        function updateThemeIcon(theme) {
            icon.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
        }

        updateThemeIcon(localStorage.getItem('theme') || 'light');

        toggleBtn?.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
            updateThemeIcon(next);
        });

        // Language dropdown functionality
        const langSelect = document.getElementById('lang-select');
        if (langSelect) {
            // Set current language in dropdown
            langSelect.value = currentLang;

            langSelect.addEventListener('change', (e) => {
                const selectedLang = e.target.value;
                localStorage.setItem('lang', selectedLang);

                // Simply replace the language code in the current path
                const newPath = window.location.pathname.replace(
                    /\/[a-z]{2}\//,
                    '/' + selectedLang + '/'
                );

                window.location.href = newPath;
            });
        }
    </script>
</body>
</html>