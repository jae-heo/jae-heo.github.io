<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python ì‹œë®¬ë ˆì´ì…˜ ë³‘ëª© ì§€ì  í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™” - ì¬ì˜ì˜ ê¸°ìˆ  ë¸”ë¡œê·¸</title>
    <meta name="description" content="ì‹œë®¬ë ˆì´ì…˜ ì½”ë“œì˜ ì„±ëŠ¥ ë³‘ëª©ì„ ì°¾ê³  ìµœì í™”í•˜ëŠ” ê³ ê¸‰ í”„ë¡œíŒŒì¼ë§ ê¸°ë²•">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="alternate" type="application/rss+xml" title="ì¬ì˜ì˜ ê¸°ìˆ  ë¸”ë¡œê·¸ RSS" href="/tech/ko/feed.xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <script>
        // Apply saved theme immediately to prevent flash
        const theme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', theme);
        // Language preference
        const lang = localStorage.getItem('lang') || 'ko';
    </script>
    <script src="/assets/js/theme-switcher.js" defer></script>
</head>
<body>
    <header>
        <nav>
            <a href="/tech/ko/" class="site-title" data-nav-link>ì¬ì˜ì˜ ê¸°ìˆ  ë¸”ë¡œê·¸</a>
            <div class="nav-links">
                <a href="/tech/ko/" data-nav-link>í™ˆ</a>
                <a href="/tech/ko/archive.html" data-nav-link>ì•„ì¹´ì´ë¸Œ</a>
                <a href="/tech/ko/about.html" data-nav-link>ì†Œê°œ</a>
                <select id="lang-select" aria-label="Select language" style="background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); cursor: pointer; font-size: 0.9rem; margin-right: 0.5rem;">
                    <option value="en">English</option>
                    <option value="ko">í•œêµ­ì–´</option>
                </select>
                <button id="theme-toggle" aria-label="ë‹¤í¬ ëª¨ë“œ ì „í™˜" style="background: none; border: none; cursor: pointer; color: var(--text-secondary); font-size: 1.2rem;">
                    <span id="theme-icon">ğŸŒ™</span>
                </button>
            </div>
        </nav>
    </header>

    <main>
        <article class="post">
    <header class="post-header">
        <h1>Python ì‹œë®¬ë ˆì´ì…˜ ë³‘ëª© ì§€ì  í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™”</h1>
        <time datetime=""2024-07-10T00:00:00.000Z"">July 10, 2024</time>
        <div style="margin-top: 1rem; display: flex; flex-direction: column; gap: 0.75rem;">
            
            
            <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                <span style="color: var(--text-secondary); font-size: 0.9rem; font-weight: 500; min-width: 70px;">ì¹´í…Œê³ ë¦¬:</span>
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <a href="/tech/ko/categories/performance.html" class="category-badge">performance</a>
                </div>
            </div>
            
            
            <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                <span style="color: var(--text-secondary); font-size: 0.9rem; font-weight: 500; min-width: 70px;">íƒœê·¸:</span>
                <div class="tags" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    
                    <a href="/tech/ko/tags/python.html" class="tag">python</a>
                    
                    <a href="/tech/ko/tags/profiling.html" class="tag">profiling</a>
                    
                    <a href="/tech/ko/tags/optimization.html" class="tag">optimization</a>
                    
                    <a href="/tech/ko/tags/performance.html" class="tag">performance</a>
                    
                    <a href="/tech/ko/tags/simulation.html" class="tag">simulation</a>
                    
                </div>
            </div>
            
        </div>
    </header>

    

    <div class="post-content">
        <h1 id="python-">Python ì‹œë®¬ë ˆì´ì…˜ ë³‘ëª© ì§€ì  í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™”</h1>
<p>ëŒ€ê·œëª¨ ì‹œë®¬ë ˆì´ì…˜ì—ì„œ 1%ì˜ ì„±ëŠ¥ ê°œì„ ë„ ì‹œê°„ê³¼ ë¹„ìš©ì„ í¬ê²Œ ì ˆì•½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì •ë°€í•œ í”„ë¡œíŒŒì¼ë§ê³¼ íƒ€ê²Ÿ ìµœì í™” ê¸°ë²•ì„ ì‚´í´ë´…ë‹ˆë‹¤.</p>
<h2 id="-">ê³„ì¸µì  í”„ë¡œíŒŒì¼ë§ ì „ëµ</h2>
<pre><code class="language-python">import cProfile
import pstats
from memory_profiler import profile
from line_profiler import LineProfiler
import tracemalloc
import sys
import gc

class SimulationProfiler:
    &quot;&quot;&quot;ë‹¤ì¸µì  ì‹œë®¬ë ˆì´ì…˜ í”„ë¡œíŒŒì¼ëŸ¬&quot;&quot;&quot;

    def __init__(self, simulation):
        self.simulation = simulation
        self.cpu_profiler = cProfile.Profile()
        self.line_profiler = LineProfiler()
        self.memory_snapshots = []

        # í”„ë¡œíŒŒì¼ë§ íƒ€ê²Ÿ ì„¤ì •
        self._setup_targets()

    def _setup_targets(self):
        &quot;&quot;&quot;í”„ë¡œíŒŒì¼ë§ ëŒ€ìƒ ë©”ì„œë“œ ë“±ë¡&quot;&quot;&quot;
        # í•«ìŠ¤íŒŸ ì˜ˆìƒ í•¨ìˆ˜ë“¤
        critical_methods = [
            self.simulation.process_event,
            self.simulation.update_state,
            self.simulation.calculate_interactions
        ]

        for method in critical_methods:
            self.line_profiler.add_function(method)

    def profile_execution(self, duration: float):
        &quot;&quot;&quot;ì „ì²´ ì‹¤í–‰ í”„ë¡œíŒŒì¼ë§&quot;&quot;&quot;
        # CPU í”„ë¡œíŒŒì¼ë§ ì‹œì‘
        self.cpu_profiler.enable()

        # ë©”ëª¨ë¦¬ ì¶”ì  ì‹œì‘
        tracemalloc.start()
        initial_snapshot = tracemalloc.take_snapshot()

        # ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
        try:
            self.simulation.run(duration)
        finally:
            # CPU í”„ë¡œíŒŒì¼ë§ ì¢…ë£Œ
            self.cpu_profiler.disable()

            # ë©”ëª¨ë¦¬ ìŠ¤ëƒ…ìƒ·
            final_snapshot = tracemalloc.take_snapshot()
            tracemalloc.stop()

            # ê²°ê³¼ ë¶„ì„
            self._analyze_results(initial_snapshot, final_snapshot)

    def _analyze_results(self, initial_snapshot, final_snapshot):
        &quot;&quot;&quot;í”„ë¡œíŒŒì¼ë§ ê²°ê³¼ ë¶„ì„&quot;&quot;&quot;
        # CPU í”„ë¡œíŒŒì¼ë§ ê²°ê³¼
        stats = pstats.Stats(self.cpu_profiler)
        stats.sort_stats(&#39;cumulative&#39;)

        print(&quot;\n=== Top 10 CPU Hotspots ===&quot;)
        stats.print_stats(10)

        # ë©”ëª¨ë¦¬ ì¦ê°€ ë¶„ì„
        top_stats = final_snapshot.compare_to(initial_snapshot, &#39;lineno&#39;)
        print(&quot;\n=== Top Memory Growth ===&quot;)
        for stat in top_stats[:10]:
            print(f&quot;{stat}&quot;)

        # ì½œ ê·¸ë˜í”„ ìƒì„±
        self._generate_callgraph()

    def _generate_callgraph(self):
        &quot;&quot;&quot;ì‹œê°ì  ì½œê·¸ë˜í”„ ìƒì„±&quot;&quot;&quot;
        import gprof2dot
        import subprocess

        # pstatsë¥¼ dot íŒŒì¼ë¡œ ë³€í™˜
        stats = pstats.Stats(self.cpu_profiler)
        stats.dump_stats(&#39;profile.stats&#39;)

        # Graphvizë¡œ ì‹œê°í™”
        subprocess.run([
            &#39;gprof2dot&#39;, &#39;-f&#39;, &#39;pstats&#39;, &#39;profile.stats&#39;,
            &#39;|&#39;, &#39;dot&#39;, &#39;-Tpng&#39;, &#39;-o&#39;, &#39;profile.png&#39;
        ], shell=True)</code></pre>
<h2 id="-">ë§ˆì´í¬ë¡œë²¤ì¹˜ë§ˆí‚¹ê³¼ ìµœì í™”</h2>
<pre><code class="language-python">import timeit
import numpy as np
from functools import wraps
import dis

def benchmark(number=1000):
    &quot;&quot;&quot;ë§ˆì´í¬ë¡œë²¤ì¹˜ë§ˆí¬ ë°ì½”ë ˆì´í„°&quot;&quot;&quot;
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # ì›Œë°ì—…
            for _ in range(10):
                func(*args, **kwargs)

            # ì‹¤ì œ ì¸¡ì •
            times = []
            for _ in range(number):
                start = timeit.default_timer()
                result = func(*args, **kwargs)
                end = timeit.default_timer()
                times.append(end - start)

            times = np.array(times)
            print(f&quot;{func.__name__}:&quot;)
            print(f&quot;  Mean: {np.mean(times)*1e6:.2f} Î¼s&quot;)
            print(f&quot;  Std: {np.std(times)*1e6:.2f} Î¼s&quot;)
            print(f&quot;  Min: {np.min(times)*1e6:.2f} Î¼s&quot;)
            print(f&quot;  Max: {np.max(times)*1e6:.2f} Î¼s&quot;)

            return result

        return wrapper
    return decorator

class OptimizationComparison:
    &quot;&quot;&quot;ìµœì í™” ê¸°ë²• ë¹„êµ&quot;&quot;&quot;

    @staticmethod
    def compare_list_operations():
        &quot;&quot;&quot;ë¦¬ìŠ¤íŠ¸ ì—°ì‚° ìµœì í™” ë¹„êµ&quot;&quot;&quot;
        n = 10000

        # ë°©ë²• 1: ë¦¬ìŠ¤íŠ¸ ì»´í”„ë¦¬í—¨ì…˜
        @benchmark(1000)
        def list_comprehension():
            return [i**2 for i in range(n)]

        # ë°©ë²• 2: map
        @benchmark(1000)
        def map_operation():
            return list(map(lambda x: x**2, range(n)))

        # ë°©ë²• 3: NumPy
        @benchmark(1000)
        def numpy_operation():
            return np.arange(n)**2

        # ë°©ë²• 4: ì‚¬ì „ í• ë‹¹
        @benchmark(1000)
        def preallocated():
            result = [0] * n
            for i in range(n):
                result[i] = i**2
            return result

        # ì‹¤í–‰
        list_comprehension()
        map_operation()
        numpy_operation()
        preallocated()

    @staticmethod
    def analyze_bytecode(func):
        &quot;&quot;&quot;ë°”ì´íŠ¸ì½”ë“œ ë¶„ì„&quot;&quot;&quot;
        print(f&quot;\n=== Bytecode for {func.__name__} ===&quot;)
        dis.dis(func)

        # ë°”ì´íŠ¸ì½”ë“œ ëª…ë ¹ì–´ ì¹´ìš´íŠ¸
        bytecode = dis.Bytecode(func)
        instruction_counts = {}

        for instr in bytecode:
            if instr.opname not in instruction_counts:
                instruction_counts[instr.opname] = 0
            instruction_counts[instr.opname] += 1

        print(&quot;\nInstruction frequency:&quot;)
        for opname, count in sorted(instruction_counts.items(),
                                   key=lambda x: x[1], reverse=True):
            print(f&quot;  {opname}: {count}&quot;)</code></pre>
<h2 id="-">ìºì‹œ ìµœì í™”ì™€ ë©”ëª¨ë¦¬ ì ‘ê·¼ íŒ¨í„´</h2>
<pre><code class="language-python">import functools
from pympler import asizeof
import sys

class CacheOptimization:
    &quot;&quot;&quot;ìºì‹œ ì¹œí™”ì  ìµœì í™”&quot;&quot;&quot;

    def __init__(self):
        self.cache_stats = {}

    @functools.lru_cache(maxsize=10000)
    def expensive_calculation(self, x: int, y: int) -&gt; float:
        &quot;&quot;&quot;ìºì‹œëœ ê³„ì‚°&quot;&quot;&quot;
        # ë³µì¡í•œ ê³„ì‚° ì‹œë®¬ë ˆì´ì…˜
        import math
        result = 0.0
        for i in range(100):
            result += math.exp(-x * y / (i + 1))
        return result

    def analyze_cache_performance(self):
        &quot;&quot;&quot;ìºì‹œ ì„±ëŠ¥ ë¶„ì„&quot;&quot;&quot;
        cache_info = self.expensive_calculation.cache_info()

        hit_rate = cache_info.hits / (cache_info.hits + cache_info.misses)
        print(f&quot;Cache hit rate: {hit_rate:.2%}&quot;)
        print(f&quot;Cache size: {cache_info.currsize}&quot;)
        print(f&quot;Max size: {cache_info.maxsize}&quot;)

        # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¸¡ì •
        cache_memory = asizeof.asizeof(self.expensive_calculation.__wrapped__)
        print(f&quot;Cache memory usage: {cache_memory / 1024:.2f} KB&quot;)

    @staticmethod
    def optimize_memory_access():
        &quot;&quot;&quot;ë©”ëª¨ë¦¬ ì ‘ê·¼ íŒ¨í„´ ìµœì í™”&quot;&quot;&quot;
        size = 1000

        # ë‚˜ìœ íŒ¨í„´: Column-major access in row-major array
        @benchmark(100)
        def bad_pattern():
            matrix = [[0] * size for _ in range(size)]
            total = 0
            for j in range(size):
                for i in range(size):
                    total += matrix[i][j]
            return total

        # ì¢‹ì€ íŒ¨í„´: Row-major access
        @benchmark(100)
        def good_pattern():
            matrix = [[0] * size for _ in range(size)]
            total = 0
            for i in range(size):
                for j in range(size):
                    total += matrix[i][j]
            return total

        # NumPy ìµœì í™”
        @benchmark(100)
        def numpy_pattern():
            matrix = np.zeros((size, size))
            return np.sum(matrix)

        bad_pattern()
        good_pattern()
        numpy_pattern()</code></pre>
<h2 id="-">ë™ì  ìµœì í™”ì™€ ì ì‘í˜• ì•Œê³ ë¦¬ì¦˜</h2>
<pre><code class="language-python">import ast
import types
import inspect

class DynamicOptimizer:
    &quot;&quot;&quot;ëŸ°íƒ€ì„ ë™ì  ìµœì í™”&quot;&quot;&quot;

    def __init__(self):
        self.optimization_history = []
        self.performance_metrics = {}

    def optimize_loop(self, func):
        &quot;&quot;&quot;ë£¨í”„ ìµœì í™”&quot;&quot;&quot;
        source = inspect.getsource(func)
        tree = ast.parse(source)

        # AST ë³€í™˜ì„ í†µí•œ ìµœì í™”
        optimizer = LoopOptimizer()
        optimized_tree = optimizer.visit(tree)

        # ìƒˆ í•¨ìˆ˜ ì»´íŒŒì¼
        code = compile(optimized_tree, &#39;&lt;optimized&gt;&#39;, &#39;exec&#39;)
        namespace = {}
        exec(code, namespace)

        return namespace[func.__name__]

class LoopOptimizer(ast.NodeTransformer):
    &quot;&quot;&quot;AST ë ˆë²¨ ë£¨í”„ ìµœì í™”&quot;&quot;&quot;

    def visit_For(self, node):
        &quot;&quot;&quot;for ë£¨í”„ ìµœì í™”&quot;&quot;&quot;
        # range() í˜¸ì¶œ ìµœì í™”
        if isinstance(node.iter, ast.Call):
            if hasattr(node.iter.func, &#39;id&#39;) and node.iter.func.id == &#39;range&#39;:
                # rangeë¥¼ xrangeë¡œ ë³€ê²½ (Python 2 ìŠ¤íƒ€ì¼)
                # ë˜ëŠ” ë‹¤ë¥¸ ìµœì í™” ì ìš©
                pass

        # ë£¨í”„ ì–¸ë¡¤ë§ ê°€ëŠ¥ì„± ì²´í¬
        if self._can_unroll(node):
            return self._unroll_loop(node)

        return self.generic_visit(node)

    def _can_unroll(self, node):
        &quot;&quot;&quot;ë£¨í”„ ì–¸ë¡¤ë§ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨&quot;&quot;&quot;
        # ê°„ë‹¨í•œ íœ´ë¦¬ìŠ¤í‹±: ì‘ì€ ê³ ì • í¬ê¸° ë£¨í”„
        if isinstance(node.iter, ast.Call):
            if hasattr(node.iter.func, &#39;id&#39;) and node.iter.func.id == &#39;range&#39;:
                if len(node.iter.args) == 1:
                    if isinstance(node.iter.args[0], ast.Constant):
                        return node.iter.args[0].value &lt;= 10
        return False

    def _unroll_loop(self, node):
        &quot;&quot;&quot;ë£¨í”„ ì–¸ë¡¤ë§&quot;&quot;&quot;
        # ë£¨í”„ ë°”ë””ë¥¼ ë³µì œí•˜ì—¬ ì–¸ë¡¤ë§
        unrolled = []
        if isinstance(node.iter.args[0], ast.Constant):
            n = node.iter.args[0].value
            for i in range(n):
                # ë£¨í”„ ë³€ìˆ˜ë¥¼ ìƒìˆ˜ë¡œ ì¹˜í™˜
                body_copy = ast.fix_missing_locations(
                    ast.copy_location(node.body[0], node)
                )
                unrolled.append(body_copy)

        return unrolled</code></pre>
<h2 id="-">ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§</h2>
<pre><code class="language-python">import psutil
import threading
import queue
import time

class RealTimeMonitor:
    &quot;&quot;&quot;ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°&quot;&quot;&quot;

    def __init__(self, simulation):
        self.simulation = simulation
        self.monitoring = False
        self.metrics_queue = queue.Queue()

        # ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
        self.collectors = {
            &#39;cpu&#39;: self._collect_cpu,
            &#39;memory&#39;: self._collect_memory,
            &#39;io&#39;: self._collect_io,
            &#39;custom&#39;: self._collect_custom
        }

    def start_monitoring(self, interval=0.1):
        &quot;&quot;&quot;ëª¨ë‹ˆí„°ë§ ì‹œì‘&quot;&quot;&quot;
        self.monitoring = True

        def monitor_loop():
            while self.monitoring:
                metrics = {}
                for name, collector in self.collectors.items():
                    metrics[name] = collector()

                self.metrics_queue.put({
                    &#39;timestamp&#39;: time.time(),
                    &#39;metrics&#39;: metrics
                })

                time.sleep(interval)

        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        monitor_thread.start()

    def _collect_cpu(self):
        &quot;&quot;&quot;CPU ë©”íŠ¸ë¦­ ìˆ˜ì§‘&quot;&quot;&quot;
        process = psutil.Process()
        return {
            &#39;usage_percent&#39;: process.cpu_percent(),
            &#39;num_threads&#39;: process.num_threads(),
            &#39;context_switches&#39;: process.num_ctx_switches()
        }

    def _collect_memory(self):
        &quot;&quot;&quot;ë©”ëª¨ë¦¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘&quot;&quot;&quot;
        process = psutil.Process()
        mem_info = process.memory_info()
        return {
            &#39;rss&#39;: mem_info.rss / 1024 / 1024,  # MB
            &#39;vms&#39;: mem_info.vms / 1024 / 1024,  # MB
            &#39;percent&#39;: process.memory_percent()
        }

    def _collect_io(self):
        &quot;&quot;&quot;I/O ë©”íŠ¸ë¦­ ìˆ˜ì§‘&quot;&quot;&quot;
        process = psutil.Process()
        io_counters = process.io_counters()
        return {
            &#39;read_bytes&#39;: io_counters.read_bytes,
            &#39;write_bytes&#39;: io_counters.write_bytes,
            &#39;read_count&#39;: io_counters.read_count,
            &#39;write_count&#39;: io_counters.write_count
        }

    def _collect_custom(self):
        &quot;&quot;&quot;ì‹œë®¬ë ˆì´ì…˜ íŠ¹í™” ë©”íŠ¸ë¦­&quot;&quot;&quot;
        return {
            &#39;events_processed&#39;: self.simulation.event_count,
            &#39;simulation_time&#39;: self.simulation.current_time,
            &#39;entities_active&#39;: len(self.simulation.active_entities)
        }

    def generate_report(self):
        &quot;&quot;&quot;ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±&quot;&quot;&quot;
        all_metrics = []

        while not self.metrics_queue.empty():
            all_metrics.append(self.metrics_queue.get())

        if not all_metrics:
            return

        # ì‹œê³„ì—´ ë¶„ì„
        import pandas as pd

        df = pd.DataFrame([m[&#39;metrics&#39;][&#39;cpu&#39;] for m in all_metrics])
        print(&quot;\n=== CPU Usage Statistics ===&quot;)
        print(df.describe())

        # ë³‘ëª© ì§€ì  ì‹ë³„
        self._identify_bottlenecks(all_metrics)

    def _identify_bottlenecks(self, metrics):
        &quot;&quot;&quot;ë³‘ëª© ì§€ì  ìë™ ì‹ë³„&quot;&quot;&quot;
        cpu_spikes = []
        memory_leaks = []

        for i, m in enumerate(metrics):
            # CPU ìŠ¤íŒŒì´í¬ ê°ì§€
            if m[&#39;metrics&#39;][&#39;cpu&#39;][&#39;usage_percent&#39;] &gt; 90:
                cpu_spikes.append((m[&#39;timestamp&#39;], m[&#39;metrics&#39;][&#39;cpu&#39;][&#39;usage_percent&#39;]))

            # ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€
            if i &gt; 0:
                mem_growth = (m[&#39;metrics&#39;][&#39;memory&#39;][&#39;rss&#39;] -
                            metrics[i-1][&#39;metrics&#39;][&#39;memory&#39;][&#39;rss&#39;])
                if mem_growth &gt; 10:  # 10MB ì´ìƒ ì¦ê°€
                    memory_leaks.append((m[&#39;timestamp&#39;], mem_growth))

        if cpu_spikes:
            print(f&quot;\nâš ï¸ CPU spikes detected: {len(cpu_spikes)} times&quot;)

        if memory_leaks:
            print(f&quot;\nâš ï¸ Potential memory leaks: {len(memory_leaks)} incidents&quot;)</code></pre>
<h2 id="-">í”„ë¡œíŒŒì¼ ê¸°ë°˜ ìë™ ìµœì í™”</h2>
<pre><code class="language-python">class AutoOptimizer:
    &quot;&quot;&quot;í”„ë¡œíŒŒì¼ ê¸°ë°˜ ìë™ ìµœì í™”&quot;&quot;&quot;

    def __init__(self):
        self.optimization_rules = []
        self._setup_rules()

    def _setup_rules(self):
        &quot;&quot;&quot;ìµœì í™” ê·œì¹™ ì„¤ì •&quot;&quot;&quot;
        self.optimization_rules = [
            {
                &#39;condition&#39;: lambda stats: stats[&#39;list_append_count&#39;] &gt; 1000,
                &#39;action&#39;: self._optimize_list_append,
                &#39;description&#39;: &#39;Convert repeated append to list comprehension&#39;
            },
            {
                &#39;condition&#39;: lambda stats: stats[&#39;nested_loop_depth&#39;] &gt; 2,
                &#39;action&#39;: self._optimize_nested_loops,
                &#39;description&#39;: &#39;Flatten nested loops&#39;
            },
            {
                &#39;condition&#39;: lambda stats: stats[&#39;repeated_calculation&#39;] &gt; 100,
                &#39;action&#39;: self._add_memoization,
                &#39;description&#39;: &#39;Add memoization for repeated calculations&#39;
            }
        ]

    def analyze_and_optimize(self, code_stats):
        &quot;&quot;&quot;ì½”ë“œ ë¶„ì„ ë° ìµœì í™”&quot;&quot;&quot;
        applied_optimizations = []

        for rule in self.optimization_rules:
            if rule[&#39;condition&#39;](code_stats):
                print(f&quot;Applying: {rule[&#39;description&#39;]}&quot;)
                rule[&#39;action&#39;]()
                applied_optimizations.append(rule[&#39;description&#39;])

        return applied_optimizations

    def _optimize_list_append(self):
        &quot;&quot;&quot;ë¦¬ìŠ¤íŠ¸ append ìµœì í™”&quot;&quot;&quot;
        # deque ì‚¬ìš© ê¶Œì¥
        print(&quot;Recommendation: Use collections.deque for frequent appends&quot;)

    def _optimize_nested_loops(self):
        &quot;&quot;&quot;ì¤‘ì²© ë£¨í”„ ìµœì í™”&quot;&quot;&quot;
        # NumPy ë²¡í„°í™” ê¶Œì¥
        print(&quot;Recommendation: Use NumPy vectorization for nested loops&quot;)

    def _add_memoization(self):
        &quot;&quot;&quot;ë©”ëª¨ì´ì œì´ì…˜ ì¶”ê°€&quot;&quot;&quot;
        # functools.lru_cache ê¶Œì¥
        print(&quot;Recommendation: Add @functools.lru_cache decorator&quot;)</code></pre>
<p>í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™”ëŠ” ë°˜ë³µì ì¸ ê³¼ì •ì…ë‹ˆë‹¤. ì¸¡ì • ì—†ëŠ” ìµœì í™”ëŠ” ì¶”ì¸¡ì— ë¶ˆê³¼í•˜ë¯€ë¡œ, í•­ìƒ ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œ ìµœì í™”ë¥¼ ì§„í–‰í•´ì•¼ í•©ë‹ˆë‹¤.</p>

    </div>

    <nav class="post-nav">
        
        <a href="/tech/ko/posts/2024-06-01-advanced-scheduling-algorithms.html" class="nav-prev">â† ì´ì‚° ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ê³ ê¸‰ ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜</a>
        
        
    </nav>
</article>
    </main>

    <footer>
        <div class="footer-content">
            <p>&copy; 2025 Jae Â· Built with custom static site generator</p>
            <div class="footer-links">
                <a href="/tech/ko/feed.xml">RSS</a>
                
                
            </div>
        </div>
    </footer>

    <script>
        // Parse current URL to get blog and language
        const pathParts = window.location.pathname.split('/').filter(p => p);
        const blogPath = pathParts[0] ? '/' + pathParts[0] : '';
        const currentLang = pathParts[1] || 'en';

        // Update navigation links - they should already be correct from server
        // This is just for dynamic client-side updates if needed
        function updateNavLinks() {
            const navLinks = document.querySelectorAll('[data-nav-link]');
            // Links are already fixed by the server, no client-side processing needed
        }

        // Theme toggle functionality
        const toggleBtn = document.getElementById('theme-toggle');
        const icon = document.getElementById('theme-icon');

        function updateThemeIcon(theme) {
            icon.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
        }

        updateThemeIcon(localStorage.getItem('theme') || 'light');

        toggleBtn?.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
            updateThemeIcon(next);
        });

        // Language dropdown functionality
        const langSelect = document.getElementById('lang-select');
        if (langSelect) {
            // Set current language in dropdown
            langSelect.value = currentLang;

            langSelect.addEventListener('change', (e) => {
                const selectedLang = e.target.value;
                localStorage.setItem('lang', selectedLang);

                // Simply replace the language code in the current path
                const newPath = window.location.pathname.replace(
                    /\/[a-z]{2}\//,
                    '/' + selectedLang + '/'
                );

                window.location.href = newPath;
            });
        }
    </script>
</body>
</html>