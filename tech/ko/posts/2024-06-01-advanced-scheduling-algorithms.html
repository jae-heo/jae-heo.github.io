<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì´ì‚° ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ê³ ê¸‰ ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ - ì¬ì˜ì˜ ê¸°ìˆ  ë¸”ë¡œê·¸</title>
    <meta name="description" content="Calendar Queue, Ladder Queue, Splay Tree ë“± O(1) ìŠ¤ì¼€ì¤„ë§ì„ ìœ„í•œ ê³ ê¸‰ ìë£Œêµ¬ì¡°">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="alternate" type="application/rss+xml" title="ì¬ì˜ì˜ ê¸°ìˆ  ë¸”ë¡œê·¸ RSS" href="/tech/ko/feed.xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <script>
        // Apply saved theme immediately to prevent flash
        const theme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', theme);
        // Language preference
        const lang = localStorage.getItem('lang') || 'ko';
    </script>
    <script src="/assets/js/theme-switcher.js" defer></script>
</head>
<body>
    <header>
        <nav>
            <a href="/tech/ko/" class="site-title" data-nav-link>ì¬ì˜ì˜ ê¸°ìˆ  ë¸”ë¡œê·¸</a>
            <div class="nav-links">
                <a href="/tech/ko/" data-nav-link>í™ˆ</a>
                <a href="/tech/ko/archive.html" data-nav-link>ì•„ì¹´ì´ë¸Œ</a>
                <a href="/tech/ko/about.html" data-nav-link>ì†Œê°œ</a>
                <select id="lang-select" aria-label="Select language" style="background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); cursor: pointer; font-size: 0.9rem; margin-right: 0.5rem;">
                    <option value="en">English</option>
                    <option value="ko">í•œêµ­ì–´</option>
                </select>
                <button id="theme-toggle" aria-label="ë‹¤í¬ ëª¨ë“œ ì „í™˜" style="background: none; border: none; cursor: pointer; color: var(--text-secondary); font-size: 1.2rem;">
                    <span id="theme-icon">ğŸŒ™</span>
                </button>
            </div>
        </nav>
    </header>

    <main>
        <article class="post">
    <header class="post-header">
        <h1>ì´ì‚° ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ê³ ê¸‰ ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜</h1>
        <time datetime=""2024-06-01T00:00:00.000Z"">June 1, 2024</time>
        
        <div style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            <span style="color: var(--text-secondary); font-size: 0.9rem; font-weight: 500;">ì¹´í…Œê³ ë¦¬:</span>
            <a href="/tech/ko/categories/algorithms.html" class="category-badge">ì•Œê³ ë¦¬ì¦˜</a>
        </div>
        
        
        <div class="tags" style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
            <span style="color: var(--text-secondary); font-size: 0.9rem; font-weight: 500;">íƒœê·¸:</span>
            
            <a href="/tech/ko/tags/des.html" class="tag">des</a>
            
            <a href="/tech/ko/tags/scheduling.html" class="tag">ìŠ¤ì¼€ì¤„ë§</a>
            
            <a href="/tech/ko/tags/algorithms.html" class="tag">ì•Œê³ ë¦¬ì¦˜</a>
            
            <a href="/tech/ko/tags/python.html" class="tag">python</a>
            
            <a href="/tech/ko/tags/performance.html" class="tag">ì„±ëŠ¥</a>
            
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="-">ì´ì‚° ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ê³ ê¸‰ ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜</h1>
<p>ëŒ€ê·œëª¨ DESì—ì„œ ì´ë²¤íŠ¸ ìŠ¤ì¼€ì¤„ë§ì€ ì „ì²´ ì„±ëŠ¥ì˜ í•µì‹¬ì…ë‹ˆë‹¤. O(log n)ì˜ í™ì„ ë„˜ì–´ O(1) ì„±ëŠ¥ì„ ë‹¬ì„±í•˜ëŠ” ê³ ê¸‰ ì•Œê³ ë¦¬ì¦˜ë“¤ì„ êµ¬í˜„í•©ë‹ˆë‹¤.</p>
<h2 id="dynamic-calendar-queue-">Dynamic Calendar Queue êµ¬í˜„</h2>
<pre><code class="language-python">import numpy as np
from dataclasses import dataclass
from typing import Optional, List
import math

@dataclass
class Event:
    time: float
    priority: int
    data: any
    __slots__ = [&#39;time&#39;, &#39;priority&#39;, &#39;data&#39;]

class DynamicCalendarQueue:
    &quot;&quot;&quot;ìë™ ë¦¬ì‚¬ì´ì§• Calendar Queue&quot;&quot;&quot;

    def __init__(self, initial_width: float = 1.0):
        self.width = initial_width
        self.n_buckets = 256  # 2ì˜ ì œê³±ìˆ˜
        self.buckets = [[] for _ in range(self.n_buckets)]

        # í†µê³„ ì •ë³´
        self.n_events = 0
        self.last_time = 0.0
        self.bucket_top = 0.0

        # ë¦¬ì‚¬ì´ì§• íŒŒë¼ë¯¸í„°
        self.resize_threshold = 2.0
        self.sample_size = 0
        self.sample_sum = 0.0

    def enqueue(self, time: float, data: any, priority: int = 0):
        &quot;&quot;&quot;O(1) í‰ê·  ì‹œê°„ ì‚½ì…&quot;&quot;&quot;
        # ë¦¬ì‚¬ì´ì§• ì²´í¬
        self._check_resize()

        # ë²„í‚· ì¸ë±ìŠ¤ ê³„ì‚°
        bucket_idx = self._get_bucket_index(time)
        event = Event(time, priority, data)

        # ë²„í‚· ë‚´ ì •ë ¬ ì‚½ì… (ì‘ì€ ë²„í‚· í¬ê¸°ë¡œ ì‹¤ì§ˆì  O(1))
        bucket = self.buckets[bucket_idx]
        insertion_idx = 0

        # ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ì‚½ì… ìœ„ì¹˜ ì°¾ê¸°
        if len(bucket) &gt; 8:  # ì„ê³„ê°’
            insertion_idx = self._binary_search_insert(bucket, time, priority)
        else:
            # ì„ í˜• íƒìƒ‰
            for i, e in enumerate(bucket):
                if e.time &gt; time or (e.time == time and e.priority &gt; priority):
                    insertion_idx = i
                    break
                insertion_idx = i + 1

        bucket.insert(insertion_idx, event)
        self.n_events += 1

        # ìƒ˜í”Œë§ (ë¦¬ì‚¬ì´ì§•ìš©)
        self.sample_size += 1
        if self.sample_size &gt; 1:
            self.sample_sum += abs(time - self.last_time)
        self.last_time = time

    def dequeue(self) -&gt; Optional[Event]:
        &quot;&quot;&quot;O(1) í‰ê·  ì‹œê°„ ì¶”ì¶œ&quot;&quot;&quot;
        if self.n_events == 0:
            return None

        # í˜„ì¬ ë²„í‚·ë¶€í„° ìˆœíšŒ
        start_bucket = int(self.bucket_top / self.width) % self.n_buckets

        for i in range(self.n_buckets):
            bucket_idx = (start_bucket + i) % self.n_buckets
            bucket = self.buckets[bucket_idx]

            if bucket:
                # ê°€ì¥ ì´ë¥¸ ì´ë²¤íŠ¸ ì¶”ì¶œ
                event = bucket.pop(0)
                self.n_events -= 1
                self.bucket_top = event.time
                return event

        return None

    def _get_bucket_index(self, time: float) -&gt; int:
        &quot;&quot;&quot;ë²„í‚· ì¸ë±ìŠ¤ ê³„ì‚°&quot;&quot;&quot;
        return int(time / self.width) &amp; (self.n_buckets - 1)

    def _binary_search_insert(self, bucket: List[Event],
                             time: float, priority: int) -&gt; int:
        &quot;&quot;&quot;ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ì‚½ì… ìœ„ì¹˜ ì°¾ê¸°&quot;&quot;&quot;
        left, right = 0, len(bucket)

        while left &lt; right:
            mid = (left + right) // 2
            if (bucket[mid].time &lt; time or
                (bucket[mid].time == time and bucket[mid].priority &lt; priority)):
                left = mid + 1
            else:
                right = mid

        return left

    def _check_resize(self):
        &quot;&quot;&quot;ë™ì  ë¦¬ì‚¬ì´ì§•&quot;&quot;&quot;
        if self.sample_size &lt; 100:
            return

        avg_gap = self.sample_sum / (self.sample_size - 1)

        # ìµœì  ë²„í‚· í­ ê³„ì‚°
        optimal_width = 3.0 * avg_gap
        ratio = optimal_width / self.width

        if ratio &gt; self.resize_threshold or ratio &lt; 1.0 / self.resize_threshold:
            self._resize(optimal_width)

    def _resize(self, new_width: float):
        &quot;&quot;&quot;ìº˜ë¦°ë” í ë¦¬ì‚¬ì´ì§•&quot;&quot;&quot;
        old_buckets = self.buckets
        self.width = new_width
        self.buckets = [[] for _ in range(self.n_buckets)]

        # ëª¨ë“  ì´ë²¤íŠ¸ ì¬ì‚½ì…
        for bucket in old_buckets:
            for event in bucket:
                bucket_idx = self._get_bucket_index(event.time)
                self.buckets[bucket_idx].append(event)

        # ê° ë²„í‚· ì •ë ¬
        for bucket in self.buckets:
            bucket.sort(key=lambda e: (e.time, e.priority))

        # ìƒ˜í”Œ ì´ˆê¸°í™”
        self.sample_size = 0
        self.sample_sum = 0.0</code></pre>
<h2 id="lazy-queue-ladder-queue-">Lazy Queue (Ladder Queue) êµ¬í˜„</h2>
<pre><code class="language-python">class LadderQueue:
    &quot;&quot;&quot;Lazy Queue for ì´ì‚° ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜&quot;&quot;&quot;

    def __init__(self, max_levels: int = 3):
        self.max_levels = max_levels

        # ë‹¤ë‹¨ê³„ ë²„í‚·
        self.levels = []
        for level in range(max_levels):
            bucket_width = 2 ** level
            n_buckets = 256 // (2 ** level)
            self.levels.append({
                &#39;width&#39;: bucket_width,
                &#39;buckets&#39;: [[] for _ in range(n_buckets)],
                &#39;n_buckets&#39;: n_buckets,
                &#39;min_time&#39;: float(&#39;inf&#39;),
                &#39;max_time&#39;: float(&#39;-inf&#39;)
            })

        # Topê³¼ Bottom
        self.top = []  # ì¦‰ì‹œ ì²˜ë¦¬í•  ì´ë²¤íŠ¸
        self.bottom = []  # Overflow ì´ë²¤íŠ¸

        self.current_time = 0

    def enqueue(self, time: int, data: any):
        &quot;&quot;&quot;O(1) ì‚½ì…&quot;&quot;&quot;
        if time == self.current_time:
            # Topì— ì§ì ‘ ì‚½ì…
            self.top.append((time, data))
            return

        # ì ì ˆí•œ ë ˆë²¨ ì°¾ê¸°
        level_idx = self._find_level(time)

        if level_idx &lt; 0:
            # Bottomì— ì‚½ì… (overflow)
            self._insert_sorted(self.bottom, (time, data))
        else:
            # í•´ë‹¹ ë ˆë²¨ ë²„í‚·ì— ì‚½ì…
            level = self.levels[level_idx]
            bucket_idx = (time // level[&#39;width&#39;]) % level[&#39;n_buckets&#39;]
            level[&#39;buckets&#39;][bucket_idx].append((time, data))

            # ë ˆë²¨ í†µê³„ ì—…ë°ì´íŠ¸
            level[&#39;min_time&#39;] = min(level[&#39;min_time&#39;], time)
            level[&#39;max_time&#39;] = max(level[&#39;max_time&#39;], time)

    def dequeue(self) -&gt; Optional[tuple]:
        &quot;&quot;&quot;O(1) í‰ê·  ì¶”ì¶œ&quot;&quot;&quot;
        # Topì—ì„œ ë¨¼ì € í™•ì¸
        if self.top:
            return self.top.pop(0)

        # ê° ë ˆë²¨ ìˆœíšŒ
        for level in self.levels:
            if level[&#39;min_time&#39;] &lt;= level[&#39;max_time&#39;]:
                # í˜„ì¬ ì‹œê°„ì˜ ë²„í‚· í™•ì¸
                bucket_idx = (self.current_time // level[&#39;width&#39;]) % level[&#39;n_buckets&#39;]

                for i in range(level[&#39;n_buckets&#39;]):
                    check_idx = (bucket_idx + i) % level[&#39;n_buckets&#39;]
                    bucket = level[&#39;buckets&#39;][check_idx]

                    if bucket:
                        # ê°€ì¥ ì´ë¥¸ ì´ë²¤íŠ¸ ì°¾ê¸°
                        min_idx = min(range(len(bucket)),
                                    key=lambda i: bucket[i][0])
                        event = bucket.pop(min_idx)

                        self.current_time = event[0]
                        return event

        # Bottom í™•ì¸
        if self.bottom:
            event = self.bottom.pop(0)
            self.current_time = event[0]
            return event

        return None

    def _find_level(self, time: int) -&gt; int:
        &quot;&quot;&quot;ì ì ˆí•œ ë ˆë²¨ ì°¾ê¸°&quot;&quot;&quot;
        time_diff = time - self.current_time

        for i, level in enumerate(self.levels):
            if time_diff &lt; level[&#39;n_buckets&#39;] * level[&#39;width&#39;]:
                return i

        return -1  # Overflow

    def _insert_sorted(self, lst: list, item: tuple):
        &quot;&quot;&quot;ì •ë ¬ëœ ì‚½ì… (Bottomìš©)&quot;&quot;&quot;
        import bisect
        bisect.insort(lst, item, key=lambda x: x[0])</code></pre>
<h2 id="splay-tree-">Splay Tree ê¸°ë°˜ ìš°ì„ ìˆœìœ„ í</h2>
<pre><code class="language-python">class SplayNode:
    &quot;&quot;&quot;Splay Tree ë…¸ë“œ&quot;&quot;&quot;
    __slots__ = [&#39;time&#39;, &#39;data&#39;, &#39;left&#39;, &#39;right&#39;, &#39;parent&#39;]

    def __init__(self, time: float, data: any):
        self.time = time
        self.data = data
        self.left = None
        self.right = None
        self.parent = None

class SplayTreeQueue:
    &quot;&quot;&quot;ìê°€ ê· í˜• Splay Tree ìš°ì„ ìˆœìœ„ í&quot;&quot;&quot;

    def __init__(self):
        self.root = None
        self.size = 0

    def enqueue(self, time: float, data: any):
        &quot;&quot;&quot;O(log n) amortized ì‚½ì…&quot;&quot;&quot;
        node = SplayNode(time, data)

        if not self.root:
            self.root = node
        else:
            self._insert(node)
            self._splay(node)

        self.size += 1

    def dequeue(self) -&gt; Optional[tuple]:
        &quot;&quot;&quot;O(log n) amortized ì¶”ì¶œ&quot;&quot;&quot;
        if not self.root:
            return None

        # ìµœì†Œê°’ ì°¾ê¸°
        min_node = self._find_min(self.root)
        self._splay(min_node)

        # ë£¨íŠ¸ê°€ ìµœì†Œê°’
        result = (self.root.time, self.root.data)

        # ë£¨íŠ¸ ì œê±°
        if self.root.right:
            self.root = self.root.right
            self.root.parent = None
        else:
            self.root = None

        self.size -= 1
        return result

    def _splay(self, node: SplayNode):
        &quot;&quot;&quot;ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ ìŠ¤í”Œë ˆì´&quot;&quot;&quot;
        while node.parent:
            parent = node.parent
            grandparent = parent.parent

            if not grandparent:
                # Zig
                if node == parent.left:
                    self._rotate_right(parent)
                else:
                    self._rotate_left(parent)
            elif node == parent.left and parent == grandparent.left:
                # Zig-Zig
                self._rotate_right(grandparent)
                self._rotate_right(parent)
            elif node == parent.right and parent == grandparent.right:
                # Zig-Zig
                self._rotate_left(grandparent)
                self._rotate_left(parent)
            elif node == parent.right and parent == grandparent.left:
                # Zig-Zag
                self._rotate_left(parent)
                self._rotate_right(grandparent)
            else:
                # Zig-Zag
                self._rotate_right(parent)
                self._rotate_left(grandparent)

    def _rotate_left(self, node: SplayNode):
        &quot;&quot;&quot;ì¢ŒíšŒì „&quot;&quot;&quot;
        right = node.right
        node.right = right.left

        if right.left:
            right.left.parent = node

        right.parent = node.parent

        if not node.parent:
            self.root = right
        elif node == node.parent.left:
            node.parent.left = right
        else:
            node.parent.right = right

        right.left = node
        node.parent = right

    def _rotate_right(self, node: SplayNode):
        &quot;&quot;&quot;ìš°íšŒì „&quot;&quot;&quot;
        left = node.left
        node.left = left.right

        if left.right:
            left.right.parent = node

        left.parent = node.parent

        if not node.parent:
            self.root = left
        elif node == node.parent.right:
            node.parent.right = left
        else:
            node.parent.left = left

        left.right = node
        node.parent = left</code></pre>
<h2 id="-">í•˜ì´ë¸Œë¦¬ë“œ ì ì‘í˜• ìŠ¤ì¼€ì¤„ëŸ¬</h2>
<pre><code class="language-python">class AdaptiveScheduler:
    &quot;&quot;&quot;ì›Œí¬ë¡œë“œì— ë”°ë¼ ìë™ ì „í™˜í•˜ëŠ” ìŠ¤ì¼€ì¤„ëŸ¬&quot;&quot;&quot;

    def __init__(self):
        self.calendar_queue = DynamicCalendarQueue()
        self.ladder_queue = LadderQueue()
        self.splay_tree = SplayTreeQueue()

        # í˜„ì¬ í™œì„± í
        self.active_queue = &#39;calendar&#39;
        self.queues = {
            &#39;calendar&#39;: self.calendar_queue,
            &#39;ladder&#39;: self.ladder_queue,
            &#39;splay&#39;: self.splay_tree
        }

        # ì„±ëŠ¥ ë©”íŠ¸ë¦­
        self.operation_times = {
            &#39;calendar&#39;: [],
            &#39;ladder&#39;: [],
            &#39;splay&#39;: []
        }

        self.switch_threshold = 100
        self.measurement_window = 1000

    def enqueue(self, time: float, data: any):
        &quot;&quot;&quot;ì ì‘í˜• ì‚½ì…&quot;&quot;&quot;
        import time as timer

        start = timer.perf_counter_ns()

        if self.active_queue == &#39;calendar&#39;:
            self.calendar_queue.enqueue(time, data)
        elif self.active_queue == &#39;ladder&#39;:
            # ì •ìˆ˜ ì‹œê°„ìœ¼ë¡œ ë³€í™˜
            self.ladder_queue.enqueue(int(time * 1000), data)
        else:
            self.splay_tree.enqueue(time, data)

        elapsed = timer.perf_counter_ns() - start
        self._record_performance(self.active_queue, elapsed)

    def dequeue(self) -&gt; Optional[tuple]:
        &quot;&quot;&quot;ì ì‘í˜• ì¶”ì¶œ&quot;&quot;&quot;
        import time as timer

        start = timer.perf_counter_ns()

        result = None
        if self.active_queue == &#39;calendar&#39;:
            event = self.calendar_queue.dequeue()
            if event:
                result = (event.time, event.data)
        elif self.active_queue == &#39;ladder&#39;:
            ladder_result = self.ladder_queue.dequeue()
            if ladder_result:
                result = (ladder_result[0] / 1000.0, ladder_result[1])
        else:
            result = self.splay_tree.dequeue()

        elapsed = timer.perf_counter_ns() - start
        self._record_performance(self.active_queue, elapsed)

        # ì£¼ê¸°ì ìœ¼ë¡œ ìµœì  í ì„ íƒ
        if len(self.operation_times[self.active_queue]) &gt;= self.measurement_window:
            self._select_optimal_queue()

        return result

    def _record_performance(self, queue_type: str, time_ns: int):
        &quot;&quot;&quot;ì„±ëŠ¥ ê¸°ë¡&quot;&quot;&quot;
        times = self.operation_times[queue_type]
        times.append(time_ns)

        # ìœˆë„ìš° í¬ê¸° ìœ ì§€
        if len(times) &gt; self.measurement_window:
            times.pop(0)

    def _select_optimal_queue(self):
        &quot;&quot;&quot;ìµœì  í ì„ íƒ&quot;&quot;&quot;
        avg_times = {}

        for queue_type, times in self.operation_times.items():
            if times:
                avg_times[queue_type] = sum(times) / len(times)

        if avg_times:
            optimal = min(avg_times, key=avg_times.get)

            if optimal != self.active_queue:
                print(f&quot;Switching from {self.active_queue} to {optimal}&quot;)
                self._migrate_events(self.active_queue, optimal)
                self.active_queue = optimal

    def _migrate_events(self, from_queue: str, to_queue: str):
        &quot;&quot;&quot;ì´ë²¤íŠ¸ ë§ˆì´ê·¸ë ˆì´ì…˜&quot;&quot;&quot;
        events = []

        # ëª¨ë“  ì´ë²¤íŠ¸ ì¶”ì¶œ
        while True:
            if from_queue == &#39;calendar&#39;:
                event = self.calendar_queue.dequeue()
                if event:
                    events.append((event.time, event.data))
                else:
                    break
            # ... ë‹¤ë¥¸ íë“¤ë„ ë™ì¼í•˜ê²Œ

        # ìƒˆ íì— ì¬ì‚½ì…
        for time, data in events:
            if to_queue == &#39;calendar&#39;:
                self.calendar_queue.enqueue(time, data)
            # ... ë‹¤ë¥¸ íë“¤ë„ ë™ì¼í•˜ê²Œ</code></pre>
<p>ì´ëŸ¬í•œ ê³ ê¸‰ ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ë©´ ìˆ˜ë°±ë§Œ ì´ë²¤íŠ¸ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆìœ¼ë©°, ì›Œí¬ë¡œë“œ íŠ¹ì„±ì— ë”°ë¼ ìµœì ì˜ ì„±ëŠ¥ì„ ë‹¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

    </div>

    <nav class="post-nav">
        
        <a href="/tech/ko/posts/2024-07-10-python-simulation-profiling.html" class="prev">â† Python ì‹œë®¬ë ˆì´ì…˜ ë³‘ëª© ì§€ì  í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™”</a>
        
        
        <a href="/tech/ko/posts/2024-05-15-python-jit-simulation.html" class="next">ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ Python JIT ì»´íŒŒì¼ëŸ¬ ìµœì í™” â†’</a>
        
    </nav>
</article>
    </main>

    <footer>
        <div class="footer-content">
            <p>&copy; 2025 Jae Â· Built with custom static site generator</p>
            <div class="footer-links">
                <a href="/tech/ko/feed.xml">RSS</a>
                
                
            </div>
        </div>
    </footer>

    <script>
        // Parse current URL to get blog and language
        const pathParts = window.location.pathname.split('/').filter(p => p);
        const blogPath = pathParts[0] ? '/' + pathParts[0] : '';
        const currentLang = pathParts[1] || 'en';

        // Update navigation links - they should already be correct from server
        // This is just for dynamic client-side updates if needed
        function updateNavLinks() {
            const navLinks = document.querySelectorAll('[data-nav-link]');
            // Links are already fixed by the server, no client-side processing needed
        }

        // Theme toggle functionality
        const toggleBtn = document.getElementById('theme-toggle');
        const icon = document.getElementById('theme-icon');

        function updateThemeIcon(theme) {
            icon.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
        }

        updateThemeIcon(localStorage.getItem('theme') || 'light');

        toggleBtn?.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
            updateThemeIcon(next);
        });

        // Language dropdown functionality
        const langSelect = document.getElementById('lang-select');
        if (langSelect) {
            // Set current language in dropdown
            langSelect.value = currentLang;

            langSelect.addEventListener('change', (e) => {
                const selectedLang = e.target.value;
                localStorage.setItem('lang', selectedLang);

                // Simply replace the language code in the current path
                const newPath = window.location.pathname.replace(
                    /\/[a-z]{2}\//,
                    '/' + selectedLang + '/'
                );

                window.location.href = newPath;
            });
        }
    </script>
</body>
</html>